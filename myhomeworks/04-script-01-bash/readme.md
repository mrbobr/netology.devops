# Домашнее задание к занятию "4.1. Командная оболочка Bash: Практические навыки"

## Обязательная задача 1

Есть скрипт:
```bash
a=1
b=2
c=a+b
d=$a+$b
e=$(($a+$b))
```

Какие значения переменным c,d,e будут присвоены? Почему?

| Переменная  | Значение | Обоснование                                                                                                                                                                                        |
| ------------- |----------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `c`  | a+b      | присвоили переменной в неявном виде строковое значение `a+b`                                                                                                                                       |
| `d`  | 1+2      | присвоили переменной в неявном виде строковое значение, состоящее из трех подстрок 'значение переменной `a`', '+', 'значение переменной `b`'                                                           |
| `e`  | 3        | при использовании конструкции с двумя круглыми или одними квадратными скобками, выражение внутри нее расценивается, как арифметическое. Т.е. переменной `e` присвоили сумму значений переменных `a` и `b` |


## Обязательная задача 2
_На нашем локальном сервере упал сервис и мы написали скрипт, который постоянно проверяет его доступность, записывая дату проверок до тех пор, пока сервис не станет доступным (после чего скрипт должен завершиться). В скрипте допущена ошибка, из-за которой выполнение не может завершиться, при этом место на Жёстком Диске постоянно уменьшается. Что необходимо сделать, чтобы его исправить:_  
> Добавить скобку в первой строке. Убрать один символ `>` в шестой строке, чтобы файл перезаписывался. Добавить в цикл оператор `break`.  
```bash
while ((1==1))
do
	curl https://localhost:4757
	if (($? != 0))
	then
	  date > curl.log
	else
	  break
	fi
done
```

Необходимо написать скрипт, который проверяет доступность трёх IP: `192.168.0.1`, `173.194.222.113`, `87.250.250.242` по `80` порту и записывает результат в файл `log`. Проверять доступность необходимо пять раз для каждого узла.

### Ваш скрипт:
```bash
#!/usr/bin/env bash
log=/tmp/log #путь к файлу
> $log
t=0s #пауза между опросами
declare -i i=0
IP=("192.168.0.1" "173.194.222.113" "87.250.250.242")
echo started...
while ((i != 5))
do
	for ip in ${IP[@]}
	do
	    curl -s $ip 1> /dev/null
	    if (($? != 0))
	    then
		    echo $ip - не доступен>> $log
        else
		    echo $ip - доступен>> $log
	    fi
      sleep $t
	done
	i+=1
done
echo done
```

## Обязательная задача 3
Необходимо дописать скрипт из предыдущего задания так, чтобы он выполнялся до тех пор, пока один из узлов не окажется недоступным. Если любой из узлов недоступен - IP этого узла пишется в файл error, скрипт прерывается.

### Ваш скрипт:
```bash
#!/usr/bin/env bash
log=/tmp/log; err=/tmp/error; #путь к файлу
> $log
t=0s #пауза между опросами
IP=("192.168.0.1" "173.194.222.113" "87.250.250.242")
echo started...
while ((1==1))
do
	for ip in ${IP[@]}
	do
		curl -s $ip 1> /dev/null
		if (($? != 0))
		then
		  echo $(date +"%d-%m-%y %T")  $ip - не доступен | tee $err
		  exit
		else
		  echo $(date +"%d-%m-%y %T")  $ip - доступен>> $log
		fi
      		sleep $t
	done
done
```

## Дополнительное задание (со звездочкой*) - необязательно к выполнению

Мы хотим, чтобы у нас были красивые сообщения для коммитов в репозиторий. Для этого нужно написать локальный хук для git, который будет проверять, что сообщение в коммите содержит код текущего задания в квадратных скобках и количество символов в сообщении не превышает 30. Пример сообщения: \[04-script-01-bash\] сломал хук.  
> Для работы хука код необходимо поместить в директорию проекта `.git/hooks`
### Ваш скрипт:
```bash
#!/usr/bin/env bash
comm_txt=$(cat "$1")
template="\[04-script-01-bash\]"
msg_limit=30
error_msg="Коммит отклонен. В тексте не обнаружен код '[04-script-01-bash]' или сообщение длиннее $msg_limit символов(а)"
echo $comm_txt | grep $template #&>/dev/null
if (($? == 1)) || ((${#comm_txt}>30))
then
  echo $error_msg
  exit 1
fi
```