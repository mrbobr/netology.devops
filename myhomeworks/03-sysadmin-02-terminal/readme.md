## Домашнее задание к занятию "3.2. Работа в терминале, лекция 2"

1. _Какого типа команда `cd`? Попробуйте объяснить, почему она именно такого типа; опишите ход своих мыслей, если считаете что она могла бы быть другого типа._
>Проверяем командой `type cd`: cd is a shell builtin. Т.е. cd является встроенной командой оболочки. Посмотрим описание `cd --help`: Change the shell working directory...  
> Из описания следует, что команда cd изменяет рабочую директории именно оболочки. Другими словами создана для работы только в ней, не затрагивая другие процессы или файлы системы.
2. _Какая альтернатива без pipe команде `grep <some_string> <some_file> | wc -l`? `man grep` поможет в ответе на этот вопрос. Ознакомьтесь с [документом](http://www.smallo.ruhr.de/award.html) о других подобных некорректных вариантах использования pipe._
> `grep -c <some_string> <some_file>`
3. _Какой процесс с PID `1` является родителем для всех процессов в вашей виртуальной машине Ubuntu 20.04?_  
> Находим процесс с данным PID, например, командой `ps -Fp1`: 
```
UID          PID    PPID  C    SZ   RSS PSR STIME TTY          TIME CMD
root           1       0  0 25451 11204   0 11:40 ?        00:00:00 /sbin/init
```
> Можно узнать, что за команда init: `whatis init` - init (1) - systemd system and service manager  
> В `man init` указано, что /sbin/init - символическая ссылка на systemd. Это также можно увидеть в расширенном выводе команды ls `ll /sbin/init`.  
4. _Как будет выглядеть команда, которая перенаправит вывод stderr `ls` на другую сессию терминала?_  
> `ls 2>/dev/pts/X` где X - номер сессии терминала
5. _Получится ли одновременно передать команде файл на stdin и вывести ее stdout в другой файл? Приведите работающий пример._
>Получится. Например: `$ wc <testfile>test_stdout`  
>Или: `awk -F: '{print$1}' < test_stdin > resfiles/test_stdout`
6. _Получится ли находясь в графическом режиме, вывести данные из PTY в какой-либо из эмуляторов TTY? Сможете ли вы наблюдать выводимые данные?_
>Для этого нужно перенаправить вывод в эмулятор TTY, в котором был выполнен логин:  
> Переходим, например, в tty3 сочетанием `ctrl+alt+F3`, выполняем вход, переходим обратно в графический режим и отправляем команду `echo 'string' >/dev/tty3`.  
> При переключении на tty3 можно будет наблюдать строку string.
7. _Выполните команду `bash 5>&1`. К чему она приведет? Что будет, если вы выполните `echo netology > /proc/$$/fd/5`? Почему так происходит?_
> Командой `bash 5>&1` запускается процесс bash, для которого создается файловый дескриптор 5 с перенаправлением в стандартный вывод 1.  
> Выполнение `echo netology > /proc/$$/fd/5` выведет `netology`, т.к. вывод команды echo перенаправлен в дескриптор 5 текущего процесса bash ($$ = его PID), из которого и запускалась echo (дочерние процессы наследуют FD). А так как дескриптор 5 перенаправлен в стандартный вывод, то мы видим его в терминале. По сути это аналогично выполнению `echo netology` :)
8. _Получится ли в качестве входного потока для pipe использовать только stderr команды, не потеряв при этом отображение stdout на pty? Напоминаем: по умолчанию через pipe передается только stdout команды слева от `|` на stdin команды справа.
Это можно сделать, поменяв стандартные потоки местами через промежуточный новый дескриптор, который вы научились создавать в предыдущем вопросе._  
> Для этого нужно перенаправить stderr в stdout, а stdout в ранее созданный дескриптор 5: `ls string 2>&1 1<&5 | grep access`
9. _Что выведет команда `cat /proc/$$/environ`? Как еще можно получить аналогичный по содержанию вывод?_  
> Список переменных окружения одной строкой. Также можно посмотреть список этих переменных, выполнив команду `env`.  
10. _Используя `man`, опишите что доступно по адресам `/proc/<PID>/cmdline`, `/proc/<PID>/exe`._
> /proc/[pid]/cmdline - доступный только для чтения файл, содержит полную командную строку для процесса, pid которого мы передаем если только процесс не является зомби.  
> /proc/[pid]/exe - файл являющийся символической ссылкой, содержащий фактический путь к исполняемой команде. Можно введя /proc/[pid]/exe, запустить еще одну копию того же исполняемого файла, который запускается процессом [pid].  
> Например, так можно посмотреть путь к исполняемому файлу текущего bash: `ll /proc/$$/exe`.
11. _Узнайте, какую наиболее старшую версию набора инструкций SSE поддерживает ваш процессор с помощью `/proc/cpuinfo`._  
``` 
vagrant@vagrant:~$ tr ' ' '\n' < /proc/cpuinfo | grep sse
sse
sse2
ssse3
sse4_1
sse4_2
```
> Старшая версия SSE - 4.  

12. _При открытии нового окна терминала и `vagrant ssh` создается новая сессия и выделяется pty. Это можно подтвердить командой `tty`, которая упоминалась в лекции 3.2. Однако:_

     ```bash
       vagrant@netology1:~$ ssh localhost 'tty'
       not a tty
     ```

     _Почитайте, почему так происходит, и как изменить поведение._
> Не нашел конфиг, в котором это указывается (возможно значение по умолчанию), но судя по man ssh и sshd при выполнении команд на удаленном хосте запрещено выделение tty.  
> Для подтверждения выполнил команду `ssh localhost 'env'` и в выводе действительно нет переменной SSH_TTY.  
> Для обхода ситуации, если команде для выполнения нужен tty, нужно использовать для `ssh` ключ -t :  
> `ssh -t localhost 'tty'`
13. _Бывает, что есть необходимость переместить запущенный процесс из одной сессии в другую. Попробуйте сделать это, воспользовавшись `reptyr`. Например, так можно перенести в `screen` процесс, который вы запустили по ошибке в обычной SSH-сессии._
> После изменения значения kernel.yama.ptrace_scope = 0, удалось переместить в screen процесс выполняемый в другом терминале.
14. _`sudo echo string > /root/new_file` не даст выполнить перенаправление под обычным пользователем, так как перенаправлением занимается процесс shell'а, который запущен без `sudo` под вашим пользователем. Для решения данной проблемы можно использовать конструкцию `echo string | sudo tee /root/new_file`. Узнайте что делает команда `tee` и почему в отличие от `sudo echo` команда с `sudo tee` будет работать._  
> `tee` - принимает данные из stdin и перенаправляет их одновременно в stdout и указанный(ые) файл(ы)  
> Первая конструкция не работает, потому что `echo` является встроенной командой оболочки и выполняется от пользователя выполнившего логин. Во второй конструкции для `tee` сначала повышаются привилегии, а затем происходит попытка записи в файл.